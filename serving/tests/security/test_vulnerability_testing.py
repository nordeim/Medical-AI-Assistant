"""
Security and vulnerability testing with PHI protection validation.

This module provides comprehensive security testing for medical AI systems including:
- PHI (Protected Health Information) protection validation
- Vulnerability scanning and penetration testing
- Authentication and authorization security
- Data encryption and secure transmission testing
- Compliance with medical data security standards (HIPAA, HL7 FHIR)
"""

import pytest
import asyncio
import json
import hashlib
import secrets
import base64
import re
from datetime import datetime, timedelta
from typing import Dict, List, Any, Tuple
from unittest.mock import Mock, patch, AsyncMock
import requests
from cryptography.fernet import Fernet
import bcrypt

from fastapi.testclient import TestClient

# Import serving components
from api.main import app
from api.middleware.security import SecurityMiddleware, AuthenticationMiddleware


class PHIScanner:
    """Scan for potential PHI exposure in text and data."""
    
    # HIPAA-defined PHI patterns
    PHI_PATTERNS = {
        'ssn': r'\b\d{3}-\d{2}-\d{4}\b|\b\d{9}\b',
        'phone': r'\b\(?(\d{3})\)?[-.\s]?(\d{3})[-.\s]?(\d{4})\b',
        'email': r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b',
        'dob': r'\b(0?[1-9]|1[0-2])[/-](0?[1-9]|[12][0-9]|3[01])[/-](19|20)\d{2}\b',
        'mrn': r'\bMRN\s*\d{6,10}\b|\b\d{6,10}\b',
        'address': r'\b\d+\s+[A-Za-z\s]+\b',
        'zip_code': r'\b\d{5}(-\d{4})?\b',
        'name': r'\b[A-Z][a-z]+\s+[A-Z][a-z]+\b',
        'license': r'\b[A-Z]{2}\d{7}\b',
        'passport': r'\b[A-Z]\d{8}\b'
    }
    
    def __init__(self):
        self.fernet = Fernet(Fernet.generate_key())  # For encryption testing
    
    def scan_text(self, text: str) -> Dict[str, Any]:
        """Scan text for PHI patterns."""
        
        findings = {}
        for pattern_name, pattern in self.PHI_PATTERNS.items():
            matches = re.findall(pattern, text, re.IGNORECASE)
            if matches:
                findings[pattern_name] = matches
        
        return {
            'text_scanned': text,
            'phi_found': len(findings) > 0,
            'findings': findings,
            'scan_timestamp': datetime.now().isoformat()
        }
    
    def test_redaction_efficiency(self, text: str, redacted_text: str) -> Dict[str, Any]:
        """Test effectiveness of PHI redaction."""
        
        original_scan = self.scan_text(text)
        redacted_scan = self.scan_text(redacted_text)
        
        original_phi_count = sum(len(matches) for matches in original_scan['findings'].values())
        redacted_phi_count = sum(len(matches) for matches in redacted_scan['findings'].values())
        
        reduction_percentage = ((original_phi_count - redacted_phi_count) / original_phi_count * 100) if original_phi_count > 0 else 0
        
        return {
            'original_phi_count': original_phi_count,
            'redacted_phi_count': redacted_phi_count,
            'reduction_percentage': reduction_percentage,
            'redaction_effective': redacted_phi_count == 0 and original_phi_count > 0,
            'scan_timestamp': datetime.now().isoformat()
        }
    
    def encrypt_test_data(self, data: str) -> str:
        """Encrypt test data for secure transmission testing."""
        return self.fernet.encrypt(data.encode()).decode()
    
    def decrypt_test_data(self, encrypted_data: str) -> str:
        """Decrypt test data."""
        return self.fernet.decrypt(encrypted_data.encode()).decode()


class VulnerabilityTester:
    """Test for common vulnerabilities in medical AI systems."""
    
    def __init__(self):
        self.payloads = {
            'sql_injection': [
                "' OR '1'='1",
                "'; DROP TABLE patients; --",
                "' UNION SELECT * FROM users --",
                "admin'--",
                "1' OR '1'='1' --"
            ],
            'xss': [
                "<script>alert('XSS')</script>",
                "javascript:alert('XSS')",
                "<img src=x onerror=alert('XSS')>",
                "';alert('XSS');//"
            ],
            'command_injection': [
                "; cat /etc/passwd",
                "| whoami",
                "&& ls -la",
                "`id`"
            ],
            'path_traversal': [
                "../../../etc/passwd",
                "..\\..\\..\\windows\\system32",
                "....//....//....//etc/passwd"
            ],
            'template_injection': [
                "{{7*7}}",
                "${7*7}",
                "#{7*7}"
            ]
        }
    
    def test_sql_injection(self, endpoint: str, client: TestClient) -> Dict[str, Any]:
        """Test for SQL injection vulnerabilities."""
        
        results = []
        for payload in self.payloads['sql_injection']:
            test_data = {
                'input': payload,
                'query': f"SELECT * FROM patients WHERE name='{payload}'"
            }
            
            try:
                response = client.post(endpoint, json=test_data)
                results.append({
                    'payload': payload,
                    'status_code': response.status_code,
                    'response_time': response.elapsed.total_seconds(),
                    'vulnerable': self._analyze_sql_injection_response(response)
                })
            except Exception as e:
                results.append({
                    'payload': payload,
                    'error': str(e),
                    'vulnerable': False
                })
        
        return {
            'endpoint': endpoint,
            'test_type': 'sql_injection',
            'results': results,
            'vulnerabilities_found': sum(1 for r in results if r.get('vulnerable', False))
        }
    
    def test_xss(self, endpoint: str, client: TestClient) -> Dict[str, Any]:
        """Test for XSS vulnerabilities."""
        
        results = []
        for payload in self.payloads['xss']:
            test_data = {
                'input': payload,
                'output_format': 'html'
            }
            
            try:
                response = client.post(endpoint, json=test_data)
                results.append({
                    'payload': payload,
                    'status_code': response.status_code,
                    'response_contains_script': payload.lower() in response.text.lower(),
                    'vulnerable': self._analyze_xss_response(response)
                })
            except Exception as e:
                results.append({
                    'payload': payload,
                    'error': str(e),
                    'vulnerable': False
                })
        
        return {
            'endpoint': endpoint,
            'test_type': 'xss',
            'results': results,
            'vulnerabilities_found': sum(1 for r in results if r.get('vulnerable', False))
        }
    
    def test_authentication_bypass(self, endpoint: str, client: TestClient) -> Dict[str, Any]:
        """Test authentication bypass attempts."""
        
        bypass_attempts = [
            {'headers': {'Authorization': 'Bearer admin'}},
            {'headers': {'Authorization': 'Bearer 123456'}},
            {'headers': {'X-User-ID': 'admin'}},
            {'headers': {'User-Id': '0'}},
            {'cookies': {'session': 'admin'}},
            {'data': {'admin': True}},
        ]
        
        results = []
        for attempt in bypass_attempts:
            try:
                response = client.post(endpoint, json={'test': 'data'}, **attempt)
                results.append({
                    'bypass_method': attempt,
                    'status_code': response.status_code,
                    'bypassed': response.status_code == 200,
                    'response_indicates_admin': 'admin' in response.text.lower() or 'administrator' in response.text.lower()
                })
            except Exception as e:
                results.append({
                    'bypass_method': attempt,
                    'error': str(e),
                    'bypassed': False
                })
        
        return {
            'endpoint': endpoint,
            'test_type': 'authentication_bypass',
            'results': results,
            'bypasses_successful': sum(1 for r in results if r.get('bypassed', False))
        }
    
    def _analyze_sql_injection_response(self, response) -> bool:
        """Analyze response for SQL injection indicators."""
        error_indicators = [
            'mysql_fetch',
            'ORA-',
            'Microsoft Ole DB',
            'PostgreSQL',
            'syntax error',
            'mysql_num_rows',
            'mysql_error'
        ]
        
        response_text = response.text.lower()
        return any(indicator.lower() in response_text for indicator in error_indicators)
    
    def _analyze_xss_response(self, response) -> bool:
        """Analyze response for XSS vulnerability indicators."""
        # Check if the payload appears unchanged in the response
        payload_indicators = ['<script>', 'javascript:', 'alert(']
        
        response_text = response.text
        return any(indicator in response_text for indicator in payload_indicators)


class TestPHIProtection:
    """Test PHI protection and compliance."""
    
    @pytest.fixture
    def client(self):
        """Create test client."""
        return TestClient(app)
    
    @pytest.fixture
    def phi_scanner(self):
        """Create PHI scanner."""
        return PHIScanner()
    
    @pytest.mark.security
    @pytest.mark.phi
    def test_phi_detection_in_inputs(self, client, phi_scanner):
        """Test PHI detection in API inputs."""
        
        phi_test_cases = [
            {
                "description": "SSN in input",
                "input": "Patient SSN: 123-45-6789 needs diabetes medication",
                "expected_phi_types": ["ssn"]
            },
            {
                "description": "Multiple PHI types",
                "input": "Call John Doe at (555) 123-4567, born 01/15/1980, MRN MRN123456",
                "expected_phi_types": ["name", "phone", "dob", "mrn"]
            },
            {
                "description": "No PHI",
                "input": "Patient presents with symptoms of diabetes",
                "expected_phi_types": []
            }
        ]
        
        for case in phi_test_cases:
            scan_result = phi_scanner.scan_text(case["input"])
            
            assert scan_result["text_scanned"] == case["input"]
            
            # Verify PHI detection
            if case["expected_phi_types"]:
                for phi_type in case["expected_phi_types"]:
                    assert phi_type in scan_result["findings"], f"Failed to detect {phi_type} in {case['input']}"
            
            # Verify clean input has no PHI
            if not case["expected_phi_types"]:
                assert not scan_result["phi_found"], f"Incorrectly detected PHI in: {case['input']}")
    
    @pytest.mark.security
    @pytest.mark.phi
    def test_phi_redaction_effectiveness(self, client, phi_scanner):
        """Test PHI redaction effectiveness."""
        
        test_cases = [
            {
                "description": "SSN redaction",
                "original": "Patient SSN: 123-45-6789, phone: (555) 123-4567",
                "redacted": "Patient SSN: [REDACTED], phone: [REDACTED]"
            },
            {
                "description": "Name and address redaction",
                "original": "John Doe lives at 123 Main St, Boston MA 02101",
                "redacted": "[NAME_REDACTED] lives at [ADDRESS_REDACTED]"
            }
        ]
        
        for case in test_cases:
            redaction_test = phi_scanner.test_redaction_efficiency(
                case["original"], case["redacted"]
            )
            
            # PHI should be effectively removed
            assert redaction_test["redaction_effective"], \
                f"Redaction failed for: {case['description']}"
            
            # Should achieve 100% reduction when PHI is present
            if phi_scanner.scan_text(case["original"])["phi_found"]:
                assert redaction_test["reduction_percentage"] == 100.0
    
    @pytest.mark.security
    @pytest.mark.phi
    def test_phi_protection_api_endpoint(self, client):
        """Test PHI protection at API endpoint level."""
        
        # Test endpoint that should sanitize PHI
        phi_request = {
            "patient_message": "My SSN is 123-45-6789 and I need help",
            "clinical_note": "Patient John Doe (DOB: 01/15/1980) called from (555) 123-4567",
            "require_phi_protection": True
        }
        
        response = client.post("/api/v1/clinical/process", json=phi_request)
        
        # Should process request successfully
        assert response.status_code == 200
        
        result = response.json()
        assert "processed_text" in result
        assert "phi_protection_applied" in result
        
        # Verify PHI protection was applied
        if result["phi_protection_applied"]:
            processed_text = result["processed_text"]
            
            # PHI patterns should be removed or replaced
            assert "123-45-6789" not in processed_text
            assert "John Doe" not in processed_text
            assert "01/15/1980" not in processed_text
            assert "(555) 123-4567" not in processed_text
    
    @pytest.mark.security
    @pytest.mark.phi
    def test_phi_audit_logging(self, client):
        """Test PHI access audit logging."""
        
        # Simulate PHI access
        phi_request = {
            "action": "view_patient_data",
            "patient_identifier": "PT_12345",
            "user_id": "clinician_001",
            "phi_accessed": True
        }
        
        response = client.post(
            "/api/v1/audit/phi-access",
            json=phi_request,
            headers={"X-Request-ID": "phi_test_001"}
        )
        
        # Should create audit log entry
        assert response.status_code == 200
        
        audit_result = response.json()
        assert "audit_id" in audit_result
        assert audit_result["phi_accessed"] is True
        assert "timestamp" in audit_result
    
    @pytest.mark.security
    @pytest.mark.phi
    def test_hipaa_compliance_headers(self, client):
        """Test HIPAA compliance headers in responses."""
        
        response = client.get("/health")
        assert response.status_code == 200
        
        headers = response.headers
        
        # Check for security headers
        assert "x-content-type-options" in headers
        assert "x-frame-options" in headers
        assert "x-xss-protection" in headers
        
        # Check for PHI protection headers (if implemented)
        compliance_headers = [
            "x-phi-protected",
            "x-hipaa-compliant",
            "x-audit-required"
        ]
        
        # At least one should be present for PHI protection
        has_phi_headers = any(header in headers for header in compliance_headers)
        assert has_phi_headers, "Missing PHI protection headers"


class TestVulnerabilityScanning:
    """Test for common security vulnerabilities."""
    
    @pytest.fixture
    def client(self):
        """Create test client."""
        return TestClient(app)
    
    @pytest.fixture
    def vuln_tester(self):
        """Create vulnerability tester."""
        return VulnerabilityTester()
    
    @pytest.mark.security
    def test_sql_injection_protection(self, client, vuln_tester):
        """Test SQL injection protection."""
        
        # Test clinical data endpoints for SQL injection
        endpoints_to_test = [
            "/api/v1/clinical/analyze",
            "/api/v1/patients/search",
            "/api/v1/medication/interactions"
        ]
        
        for endpoint in endpoints_to_test:
            result = vuln_tester.test_sql_injection(endpoint, client)
            
            # Should not have any SQL injection vulnerabilities
            assert result["vulnerabilities_found"] == 0, \
                f"SQL injection vulnerability found in {endpoint}"
    
    @pytest.mark.security
    def test_xss_protection(self, client, vuln_tester):
        """Test XSS protection."""
        
        # Test text processing endpoints for XSS
        endpoints_to_test = [
            "/api/v1/text/generate",
            "/api/v1/clinical/process",
            "/api/v1/medical-qa/question"
        ]
        
        for endpoint in endpoints_to_test:
            result = vuln_tester.test_xss(endpoint, client)
            
            # Should not have XSS vulnerabilities
            assert result["vulnerabilities_found"] == 0, \
                f"XSS vulnerability found in {endpoint}"
    
    @pytest.mark.security
    def test_authentication_security(self, client, vuln_tester):
        """Test authentication security measures."""
        
        # Test authentication-protected endpoints
        endpoints_to_test = [
            "/api/v1/patients/data",
            "/api/v1/clinical/analysis/history",
            "/api/v1/audit/logs"
        ]
        
        for endpoint in endpoints_to_test:
            result = vuln_tester.test_authentication_bypass(endpoint, client)
            
            # Should not have successful bypasses
            assert result["bypasses_successful"] == 0, \
                f"Authentication bypass successful for {endpoint}"
    
    @pytest.mark.security
    def test_input_validation(self, client):
        """Test input validation and sanitization."""
        
        # Test malicious input patterns
        malicious_inputs = [
            {
                "name": "Script injection",
                "input": "<script>alert('xss')</script>",
                "endpoint": "/api/v1/text/generate"
            },
            {
                "name": "SQL command",
                "input": "'; DROP TABLE patients; --",
                "endpoint": "/api/v1/clinical/analyze"
            },
            {
                "name": "Command injection",
                "input": "| cat /etc/passwd",
                "endpoint": "/api/v1/medical-qa/question"
            }
        ]
        
        for test_case in malicious_inputs:
            response = client.post(
                test_case["endpoint"],
                json={"input": test_case["input"]}
            )
            
            # Should either reject malicious input or sanitize it
            assert response.status_code in [200, 400, 422], \
                f"Unexpected response for {test_case['name']} at {test_case['endpoint']}"
            
            if response.status_code == 200:
                # If accepted, should be sanitized
                result = response.json()
                # Check that malicious content is not reflected unchanged
                malicious_content = test_case["input"].replace("'", "").replace(";", "")
                if "response" in result:
                    assert malicious_content not in result["response"] or \
                           "<script>" not in result["response"] or \
                           "DROP TABLE" not in result["response"]
    
    @pytest.mark.security
    def test_rate_limiting(self, client):
        """Test rate limiting protection."""
        
        # Make rapid requests to test rate limiting
        endpoint = "/api/v1/clinical/analyze"
        
        # Make many requests in quick succession
        for i in range(100):
            response = client.post(endpoint, json={
                "test": f"request_{i}",
                "data": {"symptoms": ["headache"]}
            })
            
            # Should either succeed or be rate limited
            if response.status_code == 429:  # Too Many Requests
                break
        else:
            # If no rate limiting triggered, that's a security concern
            # But for testing environment, we'll just note it
            print("Note: Rate limiting not implemented or not triggered")
    
    @pytest.mark.security
    def test_secure_headers(self, client):
        """Test security headers in responses."""
        
        response = client.get("/health")
        headers = response.headers
        
        # Check for security headers
        security_headers = {
            "x-content-type-options": "nosniff",
            "x-frame-options": "DENY",
            "x-xss-protection": "1; mode=block",
            "strict-transport-security": "max-age=31536000"
        }
        
        for header, expected_value in security_headers.items():
            assert header in headers, f"Missing security header: {header}"
            if expected_value in headers[header]:
                assert True  # Header present and contains expected security directive
    
    @pytest.mark.security
    def test_error_information_disclosure(self, client):
        """Test that error messages don't disclose sensitive information."""
        
        # Test various error scenarios
        error_endpoints = [
            "/api/v1/nonexistent",
            "/api/v1/clinical/analyze",
            "/api/v1/patients/nonexistent"
        ]
        
        for endpoint in error_endpoints:
            # Test with invalid input
            response = client.post(endpoint, json={"invalid": "data"})
            
            if response.status_code >= 400:
                error_text = response.text.lower()
                
                # Should not disclose sensitive information
                sensitive_patterns = [
                    "password",
                    "database",
                    "internal server error",
                    "stack trace",
                    "sql",
                    "table",
                    "column"
                ]
                
                for pattern in sensitive_patterns:
                    assert pattern not in error_text, \
                        f"Potentially sensitive information disclosed in error: {pattern}"


class TestDataEncryption:
    """Test data encryption and secure transmission."""
    
    @pytest.fixture
    def phi_scanner(self):
        """Create PHI scanner with encryption capabilities."""
        return PHIScanner()
    
    @pytest.mark.security
    def test_data_encryption_decryption(self, phi_scanner):
        """Test data encryption and decryption."""
        
        sensitive_data = "Patient SSN: 123-45-6789, DOB: 01/15/1980"
        
        # Test encryption
        encrypted_data = phi_scanner.encrypt_test_data(sensitive_data)
        assert encrypted_data != sensitive_data
        assert len(encrypted_data) > len(sensitive_data)
        
        # Test decryption
        decrypted_data = phi_scanner.decrypt_test_data(encrypted_data)
        assert decrypted_data == sensitive_data
    
    @pytest.mark.security
    def test_encrypted_data_resilience(self, phi_scanner):
        """Test that encrypted data is not vulnerable to pattern analysis."""
        
        # Encrypt similar data multiple times
        similar_data = [
            "Patient SSN: 123-45-6789",
            "Patient SSN: 987-65-4321",
            "Patient SSN: 111-22-3333"
        ]
        
        encrypted_results = []
        for data in similar_data:
            encrypted = phi_scanner.encrypt_test_data(data)
            encrypted_results.append(encrypted)
        
        # Each encryption should be unique
        assert len(set(encrypted_results)) == len(encrypted_results)
        
        # Encrypted data should not contain original patterns
        for encrypted in encrypted_results:
            assert "123-45-6789" not in encrypted
            assert "SSN:" not in encrypted
            assert "Patient" not in encrypted


class TestComplianceValidation:
    """Test compliance with medical data standards."""
    
    @pytest.fixture
    def client(self):
        """Create test client."""
        return TestClient(app)
    
    @pytest.mark.compliance
    def test_hipaa_compliance_checklist(self, client):
        """Test HIPAA compliance checklist."""
        
        compliance_checks = {
            "access_control": True,  # Authentication required
            "audit_controls": True,  # Logging implemented
            "integrity": True,  # Data validation
            "transmission_security": True,  # HTTPS required
            "person_or_entity_authentication": True,  # API key/token auth
            "automatic_logoff": True  # Session management
        }
        
        # Test each compliance requirement
        for requirement, implemented in compliance_checks.items():
            if implemented:
                # Test specific compliance feature
                if requirement == "access_control":
                    # Test authentication requirement
                    response = client.get("/api/v1/patients/data")
                    # Should either require auth or return appropriate error
                    assert response.status_code in [401, 403, 404]
                
                elif requirement == "audit_controls":
                    # Test audit logging
                    response = client.post("/api/v1/audit/action", json={
                        "action": "test_action",
                        "user_id": "test_user"
                    })
                    assert response.status_code == 200
                
                elif requirement == "transmission_security":
                    # Test HTTPS requirement (would need actual HTTPS setup)
                    # For testing, just verify security headers
                    response = client.get("/health")
                    headers = response.headers
                    # Should have security headers
                    assert len(headers) > 0
    
    @pytest.mark.compliance
    def test_data_minimization(self, client):
        """Test data minimization principle."""
        
        # Test that only necessary data is returned
        request = {
            "request_type": "symptom_analysis",
            "required_fields": ["symptoms", "age"],
            "optional_fields": ["medical_history", "medications"]
        }
        
        response = client.post("/api/v1/clinical/analyze", json=request)
        
        if response.status_code == 200:
            result = response.json()
            
            # Should only include requested fields or minimal necessary data
            # This is a simplified test - real implementation would be more sophisticated
            assert isinstance(result, dict)
    
    @pytest.mark.compliance
    def test_consent_management(self, client):
        """Test patient consent management."""
        
        consent_request = {
            "patient_id": "CONSENT_001",
            "consent_type": "data_processing",
            "consent_status": "granted",
            "timestamp": datetime.now().isoformat(),
            "scope": ["clinical_analysis", "research", "quality_improvement"]
        }
        
        response = client.post("/api/v1/consent/manage", json=consent_request)
        
        assert response.status_code == 200
        
        result = response.json()
        assert "consent_id" in result
        assert result["consent_status"] == "granted"
        assert "scope" in result


if __name__ == "__main__":
    pytest.main([__file__, "-v", "--tb=short", "-m", "security"])